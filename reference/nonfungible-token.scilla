scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils
library NonfungibleToken

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Check if a sender is an operator of the owner, approved for the given ID *)
(* or is the owner of the token                                             *)
let isApprovedOrOwner =
  fun (isOwner: Bool) =>
  fun (isApproved: Bool) =>
  fun (isApprovedForAll: Bool) =>
    let isOwnerOrApproved =  orb isOwner isApproved in
    orb isOwnerOrApproved isApprovedForAll

(* Error events *)
type Error =
  | CodeNotAuthorized
  | CodeNotFound
  | CodeBadRequest
  | CodeTokenExists
  | CodeUnexpectedError

let makeErrorEvent =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAuthorized    => Int32 -1
      | CodeNotFound         => Int32 -2
      | CodeBadRequest       => Int32 -3
      | CodeTokenExists      => Int32 -4
      | CodeUnexpectedError  => Int32 -5
      end
    in
    { _eventname : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NonfungibleToken
(contractOwner : ByStr20,
 name : String,
 symbol: String
)

(* Mutable fields *)

(* Mapping between tokenId to token owner *)
field tokenOwnerMap: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from owner to number of owned tokens *)
field ownedTokenCount: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Mapping between tokenId to approved address *)
(* @dev: There can only be one approved address per token at any given time. *)
field tokenApprovals: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from owner to operator approvals  *)
field operatorApprovals: Map ByStr20 (Map ByStr20 Bool) 
                            = Emp ByStr20 (Map ByStr20 Bool)

(* Emit Errors *)
procedure MakeError(err : Error)
  e = makeErrorEvent err;
  event e
end

(* @notice: Count all NFTs assigned to an owner *)
transition balanceOf(address: ByStr20) 
  optionBal <- ownedTokenCount[address];
  balance = 
    match optionBal with
    | Some bal => bal
    | None => Uint256 0
    end;
  e = {_eventname: "BalanceOfSuccess"; bal: balance};
  event e
end

(* @dev:    Mint new tokens. Only contractOwner can mint the token *)
(* @param:  to      - Address of the token recipient               *)
(* @param:  tokenId - ID of the new token minted                   *)
(* Returns error message code_token_exist if token exists          *)
transition transferSingle(to: ByStr20, tokenId: Uint256)

  (* Sender must be the contract owner *)
  isAuthorized = builtin eq contractOwner _sender;
  match isAuthorized with
  | True =>
    (* Check if token exists *)
    tokenExist <- exists tokenOwnerMap[tokenId];
    match tokenExist with
    | True =>
      (* Token exists, return error code *)
      err = CodeTokenExists;
      MakeError err
    | False =>
      (* Mint token *)
      tokenOwnerMap[tokenId] := to;
      (* Add to owner count *)
      userCnt <- ownedTokenCount[to];
      match userCnt with
      | Some val =>
        (* Append to existing results *)
        newVal= let one = Uint256 1 in builtin add val one;
        ownedTokenCount[to] := newVal
      | None =>
        (* User does not have existing tokens *)
        newVal = Uint256 1;
        ownedTokenCount[to] := newVal
      end;
      (* Emit success event *)
      e = {_eventname: "TransferSingleSuccess"; by: _sender; recipient: to; token: tokenId};
      event e
    end
  | False =>
    (* Unauthorized transaction - sender is not the contract owner*)
    err = CodeNotAuthorized;
    MakeError err
  end
end

(* @dev: Transfer the ownership of a given tokenId to another address *)
(* @param: from    - Current owner address of the token               *)
(* @param: to      - Recipient address for the token                  *)
(* @param: tokenId - ID of the token to be transferred                *)
transition transferFrom(from: ByStr20, to: ByStr20, tokenId: Uint256)

  (* Get tokenOwner ByStr20 *)
  getTokenOwner <- tokenOwnerMap[tokenId];
  match getTokenOwner with
  | None =>
    (* Token not found *)
    err = CodeNotFound;
    MakeError err  
  | Some tokenOwner =>
    checkOwner = builtin eq tokenOwner _sender;
    getApproved <- tokenApprovals[tokenId];
    checkApproved =
      match getApproved with
      | Some app => builtin eq _sender app
      | None => False
      end;
    getApprovedForAll <- operatorApprovals[tokenOwner][_sender];
    checkApprovedForAll = 
      match getApprovedForAll with 
      | Some True => True 
      | _ => False 
      end;
    (* Checks if the `from` is indeed the owner of the token *)
    isFromTokenOwner = builtin eq tokenOwner from;
    match isFromTokenOwner with
    | False =>
      (* From address is not the same as the tokenOwner    *)
      err = CodeBadRequest;
      MakeError err
    | True => 
      (* isApprovedOrOwner checks if any of the three conditions are met *)
      isAuthorized = isApprovedOrOwner checkOwner checkApproved checkApprovedForAll;
      match isAuthorized with
      | True =>
        (* Remove from Approval *)
        match checkApproved with
        | True =>
          (* Remove entry from approvals at the token level *)
          delete tokenApprovals[tokenId] 
        | False =>
        end;
        (* Change tokenOwnerMap *)
        tokenOwnerMap[tokenId] := to;
        (* Subtract one from previous token owner's count *)
        somePrevBal <- ownedTokenCount[from];
        match somePrevBal with
        | Some prevBal =>
          newBal  = let one = Uint256 1 in builtin sub prevBal one;
          ownedTokenCount[from] := newBal
        | None =>
          err = CodeUnexpectedError;
          MakeError err 
        end;
        (* Add one to the new token owner's count *)
        userCnt <- ownedTokenCount[to];
        (* Calculate the new token count value for recipient *)
        newVal = let one = Uint256 1 in match userCnt with
        | Some val =>
          (* Add to existing value *)
          builtin add val one
        | None => one
        end;
        ownedTokenCount[to] := newVal; 
        e = {_eventname: "TransferFromSuccess"; from: _sender; recipient: to; token: tokenId}; 
        event e
      | False =>
        (* Unauthorized transaction *)
        err = CodeNotAuthorized;
        MakeError err
      end
    end
  end
end

(* @dev: Approves another address the ability to transfer the given tokenId *)
(* There can only be one approved address per token at a given time         *)
(* Absence of entry in tokenApproval indicates there is no approved address *)
(* param: to      - Address to be approved for the given tokenId            *)
(* param: tokenId - ID of the token to be approved                          *)
transition approve(to: ByStr20, tokenId: Uint256)

  (* Get tokenOwner address *)
  getTokenOwner <- tokenOwnerMap[tokenId];
  match getTokenOwner with
  | None =>
    (* Token not found *)
    err = CodeNotFound;
    MakeError err
  | Some tokenOwner =>
    getApprovedForAll <- operatorApprovals[tokenOwner][_sender];
    checkApprovedForAll = 
      match getApprovedForAll with 
      | Some True => True 
      | _ => False 
      end;
    checkOwner = builtin eq _sender tokenOwner;
    isAuthorized = orb checkApprovedForAll checkOwner;
    match isAuthorized with
    | True =>
      (* Add to tokenApproval mapping *)
      tokenApprovals[tokenId] := to;
      (* Emit event *)
      e = {_eventname: "ApproveSuccess"; from: _sender; approvedTo: to; token: tokenId};
      event e
    | False =>
      (* Unauthorized transaction *)
      err = CodeNotAuthorized;
      MakeError err
    end
  end
end

(* @dev: Sets or unsets the approval of a given operator           *)
(* @param: to       - Address to be set or unset as operator       *)
(* @param: approved - Status of approval to be set for the address *)
transition setApprovalForAll(to: ByStr20, approved: Bool)

  (* Checks if the _sender is approving himself *)
  isValidOperation = let check = builtin eq _sender to in negb check;
  (* Require the approval to not be the _sender *)
  match isValidOperation with
  | True =>
    (* Check if _sender has an existing record on the operatorApproval *)
    operatorApprovals[_sender][to] := approved;
    (* Stringify boolean value to be emitted in the event *)
    approvedStr = bool_to_string approved;
    e = {_eventname: "SetApprovalForAllSuccess"; from: _sender; recipient: to; status: approvedStr};
    event e
  | False =>
    err = CodeNotAuthorized;
    MakeError err
  end
end
