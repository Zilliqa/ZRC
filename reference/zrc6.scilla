scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils PairUtils ListUtils IntUtils
library NonfungibleToken

(* User-defined ADTs *)
type Dummy =
| Dummy

type Operation =
| Add
| Sub

(* Global variables *)
let empty_str = ""
let zero = Uint256 0
let one = Uint256 1
let verdad = Dummy
let add_operation = Add
let sub_operation = Sub
let royalty_fee_bps_min = Uint256 1
let royalty_fee_bps_max = Uint256 10000

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_bal =
  fun (opt_bal: Option Uint256) =>
    match opt_bal with
    | Some bal => bal
    | None => zero
    end

(* Error exception *)
type Error =
  | NotFoundError
  | ConflictError
  | SelfError
  | NotContractOwnerError
  | NotTokenOwnerError
  | NotMinterError
  | NotApprovedError
  | NotOwnerOrOperatorError
  | InvalidFeeBpsError

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotFoundError                     => Int32 -1
      | ConflictError                     => Int32 -2
      | SelfError                         => Int32 -3
      | NotContractOwnerError             => Int32 -4
      | NotTokenOwnerError                => Int32 -5
      | NotMinterError                    => Int32 -6
      | NotApprovedError                  => Int32 -7
      | NotOwnerOrOperatorError           => Int32 -8
      | InvalidFeeBpsError                => Int32 -9
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NonfungibleToken
(
  contract_owner: ByStr20,
  name : String,
  symbol: String
)

(* Mutable fields *)

(* royalty fee BPS (1/100ths of a percent, e.g. 1000 = 10%) *)
field royalty_fee_bps: Uint256 = Uint256 1000

(* address to send royalties to *)
field royalty_recipient: ByStr20 = contract_owner

(* Base URI e.g. https://creatures-api.zilliqa.com/api/creature/ *)
field base_uri: String = ""

(* Mapping of minters available *)
field minters: Map ByStr20 Dummy =
    let emp_map = Emp ByStr20 Dummy in
    builtin put emp_map contract_owner verdad

(* Mapping between token ID to token owner *)
field token_owners: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from owner to number of owned tokens *)
field owned_token_count: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Mapping between token ID to approved address                              *)
(* @dev: There can only be one approved address per token at any given time. *)
field token_approvals: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping of token owner to operator  *)
field operator_approvals: Map ByStr20 (Map ByStr20 Dummy) = Emp ByStr20 (Map ByStr20 Dummy)

(* Total token count *)
field total_supply: Uint256 = Uint256 0

(* Used token ID *)
field token_id_count: Uint256 = Uint256 0

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsValidRoyaltyFeeBPS(fee_bps: Uint256)
  is_gte_min = uint256_ge fee_bps royalty_fee_bps_min;
  is_lte_max = uint256_le fee_bps royalty_fee_bps_max;
  
  is_valid = andb is_gte_min is_lte_max;
  match is_valid with 
    | True => 
    | False =>
      err = InvalidFeeBpsError;
      ThrowError err
  end
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = NotContractOwnerError;
    ThrowError err
  end
end

procedure IsNotSelf(address_a: ByStr20, address_b: ByStr20)
  is_self = builtin eq address_a address_b;
  match is_self with
  | False =>
  | True =>
    err = SelfError;
    ThrowError err
  end
end

procedure IsTokenIdUnique(token_id: Uint256)
  token_exist <- exists token_owners[token_id];
  match token_exist with
  | False =>
  | True =>
    err = ConflictError;
    ThrowError err
  end
end

procedure IsTokenFound(token_id: Uint256)
  token_exist <- exists token_owners[token_id];
  match token_exist with
  | True =>
  | False =>
    err = NotFoundError;
    ThrowError err
  end
end

procedure IsMinter(address: ByStr20)
  is_minter <- exists minters[address];
  match is_minter with
  | True =>
  | False =>
    err = NotMinterError;
    ThrowError err
  end
end

procedure IsTokenOwner(token_id: Uint256, address: ByStr20)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | Some addr => 
    is_token_owner = builtin eq addr address;
    match is_token_owner with
    | True =>
    | False =>
      err = NotTokenOwnerError;
      ThrowError err
    end
  | None =>
    err = NotFoundError;
    ThrowError err
  end
end

procedure IsOwnerOrOperator(token_owner: ByStr20)
  is_owner = builtin eq _sender token_owner;
  is_approved_for_all <- exists operator_approvals[token_owner][_sender];
  is_authorised = orb is_owner is_approved_for_all;
  match is_authorised with
  | True =>
  | False =>
    err = NotOwnerOrOperatorError;
    ThrowError err
  end
end

procedure IsSpenderOrOperator(token_id: Uint256, token_owner: ByStr20)
  opt_token_approval <- token_approvals[token_id];
  is_approved = match opt_token_approval with
    | None => False
    | Some approved_address => 
      builtin eq _sender approved_address
    end;
  is_operator <- exists operator_approvals[token_owner][_sender];
  is_authorised = orb is_approved is_operator;
  match is_authorised with
  | True =>
  | False =>
    err = NotApprovedError;
    ThrowError err
  end
end

procedure UpdateTokenCount(operation: Operation, address: ByStr20)
  match operation with
  | Add =>
    some_to_count <- owned_token_count[address];
    new_to_count = 
      let current_count = get_bal some_to_count in
      builtin add current_count one;
    owned_token_count[address] := new_to_count
  | Sub =>
    some_from_count <- owned_token_count[address];
    new_from_count = 
      let current_count = get_bal some_from_count in
        let is_zero = builtin eq current_count zero in
          match is_zero with
          | True => zero
          | False => builtin sub current_count one
          end;
    owned_token_count[address] := new_from_count
  end
end

procedure MintToken(to: ByStr20)
  IsMinter _sender;
  (* Add to owner count *)
  UpdateTokenCount add_operation to;
  (* Add to total_supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply;
  (* Initiate token_id and check if exists *)
  current_token_id_count <- token_id_count;
  new_token_id_count = builtin add current_token_id_count one;
  token_id_count := new_token_id_count;
  token_id = new_token_id_count;
  IsTokenIdUnique token_id;
  (* Mint new non-fungible token *)
  token_owners[token_id] := to;
  
  e = {
    _eventname : "MintSuccess";
    initiator : _sender;
    recipient : to;
    token_id : token_id
  };
  event e
end

(* @dev Gets royalty payment information for `token_id` and `sale_price`.    *)
(* It specifies how much royalty is owed and to whom for a given sale price. *)
transition RoyaltyInfo(token_id: Uint256, sale_price: Uint256)
  IsTokenFound token_id;

  current_royalty_fee_bps <- royalty_fee_bps;
  current_royalty_recipient <- royalty_recipient;

  x = builtin div royalty_fee_bps_max current_royalty_fee_bps;
  royalty_amount = builtin div sale_price x;

  msg_to_sender = { 
    _tag : "ZRC6_RoyaltyInfoCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_recipient : current_royalty_recipient;
    royalty_amount : royalty_amount
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets Uniform Resource Identifier(URI) for `token_id` *)
transition TokenURI(token_id: Uint256)
  IsTokenFound token_id;

  uri <- base_uri;

  is_empty = builtin eq uri empty_str;
  
  token_uri = match is_empty with
    | True => empty_str
    | False => 
      let id = builtin to_string token_id in
      builtin concat uri id
    end;

  msg_to_sender = { 
    _tag : "ZRC6_TokenURICallback";
    _recipient : _sender;
    _amount : Uint128 0;
    token_uri : token_uri
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets token owner for `token_id` *)
transition OwnerOf(token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | Some token_owner =>
    msg_to_sender = { 
      _tag : "ZRC6_OwnerOfCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      token_owner : token_owner
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None =>
    err = NotFoundError;
    ThrowError err
  end
end

(* @dev: Gets the NFT name *)
transition Name()
  msg_to_sender = {
    _tag : "ZRC6_NameCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    name : name
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets the NFT symbol *)
transition Symbol()
  msg_to_sender = {
    _tag : "ZRC6_SymbolCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    symbol : symbol
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets the number of tokens in `owner`s account *)
transition BalanceOf(address: ByStr20)
  some_bal <- owned_token_count[address];
  balance = get_bal some_bal;
  msg_to_sender = { 
    _tag : "ZRC6_BalanceOfCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    balance : balance
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets total amount of tokens stored by the contract *)
transition TotalSupply()
  current_supply <- total_supply;
  msg_to_sender = { 
    _tag : "ZRC6_TotalSupplyCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    total_supply : current_supply
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets account approved for `token_id` *)
transition GetApproved(token_id: Uint256)
  IsTokenFound token_id;

  opt_token_approval <- token_approvals[token_id];
  match opt_token_approval with
  | Some address => 
    msg_to_sender = { 
      _tag : "ZRC6_GetApprovedCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      approved_address : address;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None => 
    err = NotApprovedError;
    ThrowError err
  end
end

(* @dev: Checks if `operator` is allowed to manage all of the assets of `token_owner` *)
transition IsApprovedForAll(token_owner: ByStr20, operator: ByStr20)
  is_operator <- exists operator_approvals[token_owner][operator];
  msg_to_sender = { 
    _tag : "ZRC6_IsApprovedForAllCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    is_operator: is_operator
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Sets `to` as the royalty recipient. *)
(* Only contract_owner can be _sender.       *)
(* @param: to - Royalty recipient address    *)
transition SetRoyaltyRecipient(to: ByStr20)
  IsContractOwner;
  royalty_recipient := to;
  
  e = { _eventname : "SetRoyaltyRecipientSuccess"; royalty_recipient : to };
  event e;
  
  msg_to_sender = { 
    _tag : "ZRC6_SetRoyaltyRecipientCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_recipient : to
  };
  msgs = one_msg msg_to_sender;
  send msgs  
end

(* @dev: Sets `fee_bps` as royalty fee bps.      *)
(* Only contract_owner can be _sender.           *)
(* Fee bps should be in the range of 1 and 1000. *)
(* @param: fee_bps - Royalty fee BPS             *)
transition SetRoyaltyFeeBPS(fee_bps: Uint256)
  IsContractOwner;
  IsValidRoyaltyFeeBPS fee_bps;
  royalty_fee_bps := fee_bps;
  
  e = { _eventname : "SetRoyaltyFeeBPSSuccess"; royalty_fee_bps : fee_bps };
  event e;

  msg_to_sender = { 
    _tag : "ZRC6_SetRoyaltyFeeBPSCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_fee_bps : fee_bps
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Sets `uri` as the base URI. *)
(* Only contract_owner can be _sender.    *)
transition SetBaseURI(uri: String)
  IsContractOwner;
  base_uri := uri;

  e = { _eventname : "SetBaseURISuccess"; base_uri : uri };
  event e;
  
  msg_to_sender = { 
    _tag : "ZRC6_SetBaseURICallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    base_uri : uri
  };
  msgs = one_msg msg_to_sender;
  send msgs  
end

(* @dev: Adds or removes `to` as minter        *)
(* Only contract_owner can be _sender.         *)
(* @param: to - Address to be added or removed *)
transition SetMinter(to: ByStr20)
  IsContractOwner;
  is_minter <- exists minters[to];
  match is_minter with
  | True => 
    (* Remove minter *)
    delete minters[to]
  | False =>
    (* Add minter *)
    minters[to] := verdad
  end;
  new_status = negb is_minter;
  e = { 
    _eventname : "SetMinterSuccess";
    minter : to;
    is_minter: new_status
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_SetMinterCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    minter: to;
    is_minter: new_status
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Mints a token and transfers it to `to`. *)
(* Only minter can be _sender.                   *)
(* @param: to - Address of the token recipient   *)
transition Mint(to: ByStr20)
  MintToken to;
  token_id <- token_id_count;
  msg_to_recipient = { 
    _tag : "ZRC6_RecipientAcceptMint";
    _recipient : to;
    _amount : Uint128 0
  };
  msg_to_sender = { 
    _tag : "ZRC6_MintCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    recipient : to;
    token_id : token_id
  };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev: Mints tokens and transfers them to `to_list`.        *)
(* Only minter can be _sender.                                *)
(* @param: to_list - List of addresses of the token recipient *)
transition BatchMint(to_list: List ByStr20)
  forall to_list MintToken;
  msg_to_sender = { 
    _tag : "ZRC6_BatchMintCallback";
    _recipient : _sender;
    _amount : Uint128 0
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Destroys `token_id`                               *)
(* Only token_owner or operator can be _sender.            *)
(* The approval is cleared when the token is burned.       *)
(* @param: token_id - Unique ID of the NFT to be destroyed *)
transition Burn(token_id: Uint256)
  (* Check if token exists *)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = NotFoundError;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperator token_owner;
    (* Destroy existing token *)
    delete token_owners[token_id];
    delete token_approvals[token_id];

    (* Deduct from owned_token_count *)
    UpdateTokenCount sub_operation token_owner;
    (* Deduct from total_supply *)
    current_supply <- total_supply;
    new_supply = builtin sub current_supply one;
    total_supply := new_supply;
    e = {
      _eventname : "BurnSuccess";
      initiator : _sender;
      burn_address : token_owner;
      token_id : token_id
    };
    event e;
    msg_to_sender = { 
      _tag : "ZRC6_BurnCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      initiator : _sender;
      burn_address : token_owner;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* @dev: Adds or removes `to` as spender of `token_id`        *)
(* Only token_owner or operator can be _sender.               *)
(* There can only be one spender per token at any given time. *)
(* The approval is cleared when the token is transferred.     *)
(* param: to - Address to be added or removed                 *)
(* param: token_id - Unique ID of the NFT                     *)
transition SetApproval(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = NotFoundError;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperator token_owner;
    opt_approved <- token_approvals[token_id];

    (* remove if true, otherwise put *)
    should_remove = match opt_approved with
    | None => False
    | Some spender => builtin eq to spender
    end;
    match should_remove with
      | True =>
      (* Remove spender *)
      delete token_approvals[token_id]
      | False =>
      (* Add spender *)
      token_approvals[token_id] := to
    end;
    
    new_status = negb should_remove;

    e = {
      _eventname : "SetApprovalSuccess";
      initiator : _sender;
      spender : to;
      token_id : token_id;
      is_spender: new_status
    };
    event e;
    msg_to_sender = { 
      _tag : "ZRC6_SetApprovalCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      spender : to;
      token_id : token_id;
      is_spender: new_status
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* @dev: Adds or removes `to` as an operator for the _sender *)
(* @param: to - Address to be added or removed               *)
transition SetApprovalForAll(to: ByStr20)
  IsNotSelf to _sender;
  is_operator <- exists operator_approvals[_sender][to];
  match is_operator with
  | False =>
    (* Add operator *)
    operator_approvals[_sender][to] := verdad
  | True =>
    (* Remove operator *)
    delete operator_approvals[_sender][to]
  end;
  new_status = negb is_operator;
  e = {
    _eventname : "SetApprovalForAllSuccess";
    initiator : _sender;
    operator : to;
    is_operator : new_status
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_SetApprovalForAllCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    operator : to;
    is_operator : new_status
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Transfers `token_id` from the token owner to `to`.  *)
(* Only token_owner can be _sender.                          *)
(* @param: to - Recipient address for the token              *)
(* @param: token_id - Unique ID of the NFT to be transferred *)
transition Transfer(to: ByStr20, token_id: Uint256)
  IsNotSelf to _sender;
  IsTokenOwner token_id _sender;
  (* Change token_owner for that token_id *)
  token_owners[token_id] := to;
  (* Delete tokenApproval entry for that token_id *)
  delete token_approvals[token_id];
  (* Subtract one from previous token owner count *)
  UpdateTokenCount sub_operation _sender;
  (* Add one to the new token owner count *)
  UpdateTokenCount add_operation to;
  e = {
    _eventname : "TransferSuccess";
    from : _sender;
    recipient : to;
    token_id : token_id
  };
  event e;

  msg_to_recipient = { 
    _tag : "ZRC6_RecipientAcceptTransfer";
    _recipient : to;
    _amount : Uint128 0;
    from : _sender;
    recipient : to;
    token_id : token_id
  };

  msg_to_sender = { 
    _tag : "ZRC6_TransferCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    from : _sender;
    recipient : to;
    token_id : token_id
  };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev: Transfers `token_id` from the token owner to `to`.  *)
(* Only spender or operator can be _sender.                  *)
(* @param: to       - Recipient address for the NFT          *)
(* @param: token_id - Unique ID of the NFT to be transferred *)
transition TransferFrom(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = NotFoundError;
    ThrowError err
  | Some token_owner =>
    IsNotSelf to token_owner;
    IsSpenderOrOperator token_id token_owner;
    (* Change token_owner for that token_id *)
    token_owners[token_id] := to;
    (* Delete tokenApproval entry for that token_id *)
    delete token_approvals[token_id];
    (* Subtract one from previous token owner count *)
    UpdateTokenCount sub_operation token_owner;
    (* Add one to the new token owner count *)
    UpdateTokenCount add_operation to;
    e = {
      _eventname : "TransferFromSuccess";
      from : token_owner;
      recipient : to;
      token_id : token_id
    };
    event e;
    msg_to_recipient = { 
      _tag : "ZRC6_RecipientAcceptTransferFrom";
      _recipient : to;
      _amount : Uint128 0;
      from : token_owner;
      recipient : to;
      token_id : token_id
    };
    msg_to_sender = { 
      _tag : "ZRC6_TransferFromCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      from : token_owner;
      recipient : to;
      token_id : token_id
    };
    msgs = two_msgs msg_to_recipient msg_to_sender;
    send msgs
  end
end
