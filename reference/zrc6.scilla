scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils IntUtils
library NonfungibleToken

(* User-defined ADTs *)
type Dummy =
| Dummy

type Operation =
| Add
| Sub

(* Global variables *)
let zero_address = 0x0000000000000000000000000000000000000000
let false = False
let true = True
let zero = Uint256 0
let one = Uint256 1
let verdad = Dummy
let add_operation = Add
let sub_operation = Sub
let min_fee_bps = Uint128 1
let max_fee_bps = Uint128 10000

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_bal =
  fun (opt_bal: Option Uint256) =>
    match opt_bal with
    | Some bal => bal
    | None => zero
    end

(* Error exception *)
type Error =
  | NotPausedError
  | PausedError
  | SelfError
  | NotContractOwnerError
  | NotContractOwnerCandidateError
  | NotTokenOwnerError
  | NotMinterError
  | NotOwnerOrOperatorError
  | MinterNotFoundError
  | MinterFoundError
  | SpenderNotFoundError
  | SpenderFoundError
  | OperatorNotFoundError
  | OperatorFoundError
  | NotAllowedToTransferError
  | TokenNotFoundError
  | InvalidFeeBpsError
  | ZeroAddressDestinationError
  | ThisAddressDestinationError

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotPausedError                 => Int32 -1
      | PausedError                    => Int32 -2
      | SelfError                      => Int32 -3
      | NotContractOwnerError          => Int32 -4
      | NotContractOwnerCandidateError => Int32 -5
      | NotTokenOwnerError             => Int32 -6
      | NotMinterError                 => Int32 -7
      | NotOwnerOrOperatorError        => Int32 -8
      | MinterNotFoundError            => Int32 -9
      | MinterFoundError               => Int32 -10
      | SpenderNotFoundError           => Int32 -11
      | SpenderFoundError              => Int32 -12
      | OperatorNotFoundError          => Int32 -13
      | OperatorFoundError             => Int32 -14
      | NotAllowedToTransferError      => Int32 -15
      | TokenNotFoundError             => Int32 -16
      | InvalidFeeBpsError             => Int32 -17
      | ZeroAddressDestinationError    => Int32 -18
      | ThisAddressDestinationError    => Int32 -19
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NonfungibleToken
(
  initial_contract_owner: ByStr20,
  (* Initial Base URI. e.g. `https://creatures-api.zilliqa.com/api/creature/` *)
  initial_base_uri: String,
  name : String,
  symbol: String
)

(* Mutable fields *)

(* Emergency stop mechanism *)
(* Defaults to False *)
field is_paused: Bool = false

(* Token Name *)
(* Defaults to `name` *)
(* No need to mutate this field since this is for remote fetch to retrieve the immutable parameter. *)
field token_name: String = name

(* Token Symbol *)
(* Defaults to `symbol` *)
(* No need to mutate this field since this is for remote fetch to retrieve the immutable parameter. *)
field token_symbol: String = symbol

(* Contract Owner *)
(* Defaults to `initial_contract_owner` *)
field contract_owner: ByStr20 = initial_contract_owner

(* Contract owner candidate *)
(* Defaults to `zero_address` *)
field contract_owner_candidate: ByStr20 = zero_address

(* Address to send royalties to *)
(* Defaults to `initial_contract_owner` *)
field royalty_recipient: ByStr20 = initial_contract_owner

(* Royalty fee BPS (1/100ths of a percent, e.g. 1000 = 10%) *)
(* Defaults to 1000 *)
field royalty_fee_bps: Uint128 = Uint128 1000

(* Base URI *)
(* Defaults to `initial_base_uri` *)
field base_uri: String = initial_base_uri

(* Mapping from token ID to its owner *)
field token_owners: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* The total number of tokens minted *)
field token_id_count: Uint256 = Uint256 0

(* The total number of existing tokens *)
field total_supply: Uint256 = Uint256 0

(* Mapping from token owner to the number of existing tokens *)
field balances: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Set for minters *)
(* `initial_contract_owner` is a minter by default *)
field minters: Map ByStr20 Dummy =
    let emp_map = Emp ByStr20 Dummy in
    builtin put emp_map initial_contract_owner verdad

(* Mapping from token ID to a spender *)
field spenders: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from token owner to operators authorized by the token owner *)
field operators: Map ByStr20 (Map ByStr20 Dummy) = Emp ByStr20 (Map ByStr20 Dummy)

(* Emit Errors *)
procedure Throw(error : Error)
  e = make_error error;
  throw e
end

procedure RequireNotPaused()
  (* Reference: *)
  (* https://consensys.github.io/smart-contract-best-practices/general_philosophy/#prepare-for-failure *)
  paused <- is_paused;
  match paused with
  | False =>
  | True =>
    (* Contract is paused *)
    error = PausedError;
    Throw error
  end
end

procedure RequireValidRoyaltyFee(fee_bps: Uint128)
  is_gte_min = uint128_ge fee_bps min_fee_bps;
  is_lte_max = uint128_le fee_bps max_fee_bps;
  
  is_valid = andb is_gte_min is_lte_max;
  match is_valid with 
    | True => 
    | False =>
      error = InvalidFeeBpsError;
      Throw error
  end
end

procedure RequireContractOwner()
  cur_owner <- contract_owner;
  is_contract_owner = builtin eq cur_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    error = NotContractOwnerError;
    Throw error
  end
end

procedure RequireNotSelf(address_a: ByStr20, address_b: ByStr20)
  is_self = builtin eq address_a address_b;
  match is_self with
  | False =>
  | True =>
    error = SelfError;
    Throw error
  end
end

procedure RequireExistingToken(token_id: Uint256)
  has_token <- exists token_owners[token_id];
  match has_token with
  | True =>
  | False =>
    error = TokenNotFoundError;
    Throw error
  end
end

procedure RequireValidDestination(to: ByStr20)
  (* Reference: https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/tokens.md *)
  is_zero_address = builtin eq to zero_address;
  match is_zero_address with
  | False =>
  | True =>
    error = ZeroAddressDestinationError;
    Throw error
  end;

  is_this_address = builtin eq to _this_address;
  match is_this_address with
  | False =>
  | True =>
    error = ThisAddressDestinationError;
    Throw error
  end
end

procedure IsMinter(address: ByStr20)
  has_minter <- exists minters[address];
  match has_minter with
  | True =>
  | False =>
    error = NotMinterError;
    Throw error
  end
end

procedure RequireTokenOwner(token_id: Uint256, address: ByStr20)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | Some addr => 
    is_token_owner = builtin eq addr address;
    match is_token_owner with
    | True =>
    | False =>
      error = NotTokenOwnerError;
      Throw error
    end
  | None =>
    error = TokenNotFoundError;
    Throw error
  end
end

procedure RequireOwnerOrOperator(address: ByStr20)
  is_owner = builtin eq _sender address;
  has_operator <- exists operators[address][_sender];
  is_allowed = orb is_owner has_operator;
  match is_allowed with
  | True =>
  | False =>
    error = NotOwnerOrOperatorError;
    Throw error
  end
end

procedure RequireAccessToTransfer(token_owner: ByStr20, token_id: Uint256)  
  (* check if _sender is token owner *)
  is_token_owner = builtin eq token_owner _sender;
  
  (* check if _sender is spender *)
  opt_spender <- spenders[token_id];
  is_spender = match opt_spender with
    | None => False
    | Some spender => 
      builtin eq spender _sender
    end;

  (* check if _sender is operator *)
  is_operator <- exists operators[token_owner][_sender];
  
  is_spender_or_operator = orb is_spender is_operator;
  is_allowed = orb is_spender_or_operator is_token_owner;
  match is_allowed with
  | True =>
  | False =>
    error = NotAllowedToTransferError;
    Throw error
  end
end

procedure UpdateBalance(operation: Operation, address: ByStr20)
  match operation with
  | Add =>
    opt_to_count <- balances[address];
    new_to_count = 
      let current_count = get_bal opt_to_count in
      builtin add current_count one;
    balances[address] := new_to_count
  | Sub =>
    opt_from_count <- balances[address];
    new_from_count = 
      let current_count = get_bal opt_from_count in
        let is_zero = builtin eq current_count zero in
          match is_zero with
          | True => zero
          | False => builtin sub current_count one
          end;
    balances[address] := new_from_count
  end
end

procedure MintToken(to: ByStr20)
  RequireNotPaused;
  IsMinter _sender;

  (* generate ID *)
  current_token_id_count <- token_id_count;
  new_token_id_count = builtin add current_token_id_count one;
  token_id_count := new_token_id_count;
  token_id = new_token_id_count;

  (* mint a new token *)
  token_owners[token_id] := to;

  (* add one to the token owner balance *)
  UpdateBalance add_operation to;
  
  (* add one to the total supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply;
  
  e = {
    _eventname : "Mint";
    initiator : _sender;
    to : to;
    token_id : token_id
  };
  event e
end

(* @dev Gets royalty payment information for `token_id` and `sale_price`. *)
(* It specifies how much royalty is owed and to whom for a given sale price. *)
(* @Requirements: *)
(* - `token_id` should exist. Otherwise, it should throw `TokenNotFoundError` *)
transition RoyaltyInfo(token_id: Uint256, sale_price: Uint128)
  RequireExistingToken token_id;

  fee_bps <- royalty_fee_bps;  

  (* To avoid integer overflow, use division only. *)
  (* sale_price / ( max_fee_bps / fee_bps ) *)
  
  (* fee_bps ranges from 1 to 10000. *)
  x = builtin div max_fee_bps fee_bps;
  
  (* x ranges from 1 to 10000. *)
  royalty_amount = builtin div sale_price x;
  
  recipient <- royalty_recipient;

  msg_to_sender = { 
    _tag : "ZRC6_RoyaltyInfoCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_recipient : recipient;
    royalty_amount : royalty_amount
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Gets Uniform Resource Identifier(URI) for `token_id`. *)
(* @Requirements *)
(* - `token_id` should exist. Otherwise, it should throw `TokenNotFoundError` *)
transition TokenURI(token_id: Uint256)
  RequireExistingToken token_id;

  uri <- base_uri;

  id = builtin to_string token_id;
  token_uri = builtin concat uri id;
  
  msg_to_sender = { 
    _tag : "ZRC6_TokenURICallback";
    _recipient : _sender;
    _amount : Uint128 0;
    token_uri : token_uri
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Pauses the contract. Use this when things are going wrong ('circuit breaker'). *)
(* @Requirements: *)
(* - The contract should not be paused. Otherwise, it should throw `PausedError` *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
transition Pause()
  RequireNotPaused;
  RequireContractOwner;

  is_paused := true;
  e = {
    _eventname : "Pause";
    initiator : _sender;
    is_paused : true
  };
  event e;
  msg_to_sender = {
    _tag : "ZRC6_PauseCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    is_paused : true
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Unpauses the contract. *)
(* @Requirements: *)
(* - The contract should be paused. Otherwise, it should throw `NotPausedError` *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
transition Unpause()
  paused <- is_paused;
  match paused with
  | True =>
  | False =>
    error = NotPausedError;
    Throw error
  end;
  RequireContractOwner;

  is_paused := false;
  e = {
    _eventname : "Unpause";
    initiator : _sender;
    is_paused : false
  };
  event e;
  msg_to_sender = {
    _tag : "ZRC6_UnpauseCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    is_paused : false
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Sets `to` as the contract owner candidate. *)
(* To reset `contract_owner_candidate`, use `zero_address`. *)
(* i.e., `0x0000000000000000000000000000000000000000` *)
(* @param: to - contract owner candidate address  *)
(* @Requirements: *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
(* - `_sender` should not be `to`. Otherwise, it should throw `SelfError` *)
transition SetContractOwnerCandidate(to: ByStr20)
  RequireContractOwner;
  RequireNotSelf to _sender;
  contract_owner_candidate := to;
  e = {
    _eventname : "SetContractOwnerCandidate";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = {
    _tag : "ZRC6_SetContractOwnerCandidateCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to : to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Sets `contract_owner_candidate` as the contract owner. *)
(* @Requirements: *)
(* - `_sender` should be the contract owner candidate. Otherwise, it should throw `NotContractOwnerCandidateError` *)
transition AcceptContractOwnership()
  candidate <- contract_owner_candidate;

  is_candidate = builtin eq _sender candidate;
  match is_candidate with
  | False =>
    error = NotContractOwnerCandidateError;
    Throw error
  | True =>
    contract_owner := _sender;
    contract_owner_candidate := zero_address;

    e = {
      _eventname : "AcceptContractOwnership";
      initiator : _sender;
      contract_owner : _sender;
      contract_owner_candidate: zero_address
    };
    event e;
    msg_to_sender = {
      _tag : "ZRC6_AcceptContractOwnershipCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      contract_owner : _sender;
      contract_owner_candidate: zero_address
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* Sets `to` as the royalty recipient. *)
(* @param: to - Royalty recipient address  *)
(* @Requirements: *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
transition SetRoyaltyRecipient(to: ByStr20)
  RequireContractOwner;
  royalty_recipient := to;
  
  e = { 
    _eventname : "SetRoyaltyRecipient";
    initiator : _sender;
    to : to
  };
  event e;
  
  msg_to_sender = { 
    _tag : "ZRC6_SetRoyaltyRecipientCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    to : to
  };
  msgs = one_msg msg_to_sender;
  send msgs  
end

(* Sets `fee_bps` as royalty fee bps. *)
(* @param: fee_bps - Royalty fee BPS *)
(* @Requirements: *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
(* - `fee_bps` should be in the range of 1 and 1000. Otherwise, it should throw `InvalidFeeBpsError` *)
transition SetRoyaltyFeeBPS(fee_bps: Uint128)
  RequireContractOwner;
  RequireValidRoyaltyFee fee_bps;
  royalty_fee_bps := fee_bps;
  
  e = { 
    _eventname : "SetRoyaltyFeeBPS";
    initiator : _sender; 
    royalty_fee_bps : fee_bps
  };
  event e;

  msg_to_sender = { 
    _tag : "ZRC6_SetRoyaltyFeeBPSCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_fee_bps : fee_bps
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Sets `uri` as the base URI. *)
(* @Requirements: *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
transition SetBaseURI(uri: String)
  RequireContractOwner;
  base_uri := uri;

  e = { 
    _eventname : "SetBaseURI";
    initiator : _sender;
    base_uri : uri
  };
  event e;
  
  msg_to_sender = { 
    _tag : "ZRC6_SetBaseURICallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    base_uri : uri
  };
  msgs = one_msg msg_to_sender;
  send msgs  
end

(* Mints a token and transfers it to `to`. *)
(* @param: to - Address of the token recipient   *)
(* @Requirements: *)
(* - The contract should not be paused. Otherwise, it should throw `PausedError` *)
(* - `_sender` should be a minter. Otherwise, it should throw `NotMinterError` *)
transition Mint(to: ByStr20)
  MintToken to;
  token_id <- token_id_count;
  msg_to_recipient = { 
    _tag : "ZRC6_RecipientAcceptMint";
    _recipient : to;
    _amount : Uint128 0
  };
  msg_to_sender = { 
    _tag : "ZRC6_MintCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to : to;
    token_id : token_id
  };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* Mints tokens and transfers them to `to_list`. *)
(* @param: to_list - List of addresses of the token recipient *)
(* @Requirements: *)
(* - The contract should not be paused. Otherwise, it should throw `PausedError` *)
(* - `_sender` should be a minter. Otherwise, it should throw `NotMinterError` *)
transition BatchMint(to_list: List ByStr20)
  forall to_list MintToken;
  msg_to_sender = { 
    _tag : "ZRC6_BatchMintCallback";
    _recipient : _sender;
    _amount : Uint128 0
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Destroys `token_id`. *)
(* @param: token_id - Unique ID of the NFT to be destroyed *)
(* @Requirements: *)
(* - The contract should not be paused. Otherwise, it should throw `PausedError` *)
(* - `token_id` should exist. Otherwise, it should throw `TokenNotFoundError` *)
(* - `_sender` should be a token owner or an operator. Otherwise, it should throw `NotOwnerOrOperatorError` *)
transition Burn(token_id: Uint256)
  RequireNotPaused;
  (* Check if token exists *)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    error = TokenNotFoundError;
    Throw error
  | Some token_owner =>
    RequireOwnerOrOperator token_owner;
    (* Destroy existing token *)
    delete token_owners[token_id];
    delete spenders[token_id];

    (* subtract one from the balance *)
    UpdateBalance sub_operation token_owner;
    (* subtract one from the total supply *)
    current_supply <- total_supply;
    new_supply = builtin sub current_supply one;
    total_supply := new_supply;
    e = {
      _eventname : "Burn";
      initiator : _sender;
      burn_address : token_owner;
      token_id : token_id
    };
    event e;
    msg_to_sender = { 
      _tag : "ZRC6_BurnCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      burn_address : token_owner;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* Adds `to` as minter. *)
(* @Requirements: *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
(* - `to` should not be already a minter. Otherwise, it should throw `MinterFoundError` *)
transition AddMinter(to: ByStr20)
  RequireContractOwner;
  has_minter <- exists minters[to];
  match has_minter with
  | True => 
    error = MinterFoundError;
    Throw error
  | False =>
    (* Add minter *)
    minters[to] := verdad
  end;
  e = { 
    _eventname : "AddMinter";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_AddMinterCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to: to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Removes `to` from minter. *)
(* @Requirements: *)
(* - `_sender` should be the contract owner. Otherwise, it should throw `NotContractOwnerError` *)
(* - `to` should be already a minter. Otherwise, it should throw `MinterNotFoundError` *)
transition RemoveMinter(to: ByStr20)
  RequireContractOwner;
  has_minter <- exists minters[to];
  match has_minter with
  | True => 
    delete minters[to]
  | False =>
    error = MinterNotFoundError;
    Throw error
  end;
  e = { 
    _eventname : "RemoveMinter";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_RemoveMinterCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to: to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Adds `to` as spender of `token_id`. *)
(* There can only be one spender per token at any given time. *)
(* @Requirements: *)
(* - `token_id` should exist. Otherwise, it should throw `TokenNotFoundError` *)
(* - `_sender` should be a token owner or an operator. Otherwise, it should throw `NotOwnerOrOperatorError` *)
(* - `to` should not be already a spender. Otherwise, it should throw `SpenderFoundError` *)
transition AddSpender(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    error = TokenNotFoundError;
    Throw error
  | Some token_owner =>
    RequireOwnerOrOperator token_owner;
    
    has_spender <- exists spenders[token_id];
    match has_spender with
      | True =>
      error = SpenderFoundError;
      Throw error
      | False =>
      (* Add spender *)
      spenders[token_id] := to
    end;
    
    e = {
      _eventname : "AddSpender";
      initiator : _sender;
      to : to;
      token_id : token_id
    };
    event e;
    
    msg_to_sender = { 
      _tag : "ZRC6_AddSpenderCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      to : to;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* Removes `to` from spender of `token_id`. *)
(* @Requirements: *)
(* - `token_id` should exist. Otherwise, it should throw `TokenNotFoundError` *)
(* - `_sender` should be a token owner or an operator. Otherwise, it should throw `NotOwnerOrOperatorError` *)
(* - `to` should be already a spender. Otherwise, it should throw `SpenderNotFoundError` *)
transition RemoveSpender(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    error = TokenNotFoundError;
    Throw error
  | Some token_owner =>
    RequireOwnerOrOperator token_owner;
    
    has_spender <- exists spenders[token_id];
    match has_spender with
    | True =>
      (* Remove spender *)
      delete spenders[token_id]
    | False =>
      error = SpenderNotFoundError;
      Throw error
    end;
    
    e = {
      _eventname : "RemoveSpender";
      initiator : _sender;
      to : to;
      token_id : token_id
    };
    event e;

    msg_to_sender = { 
      _tag : "ZRC6_RemoveSpenderCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      to : to;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* Adds `to` as operator for the `_sender`. *)
(* @Requirements: *)
(* - `_sender` should be the token owner. Otherwise, it should throw `NotTokenOwnerError` *)
(* - `_sender` should not be `to`. Otherwise, it should throw `SelfError` *)
(* - `to` should not be already an operator. Otherwise, it should throw `OperatorFoundError` *)
transition AddOperator(to: ByStr20)
  RequireNotSelf to _sender;
  
  opt_bal <- balances[_sender];
  balance = get_bal opt_bal;
  
  is_balance_zero = builtin eq zero balance;
  (* _sender should have at least 1 token *)
  match is_balance_zero with 
  | True =>    
    error = NotTokenOwnerError;
    Throw error
  | False =>
    has_operator <- exists operators[_sender][to];
    match has_operator with
    | False =>
      (* Add operator *)
      operators[_sender][to] := verdad
    | True =>
      error = OperatorFoundError;
      Throw error
    end;
    e = {
      _eventname : "AddOperator";
      initiator : _sender;
      to : to
    };
    event e;
    msg_to_sender = {
      _tag : "ZRC6_AddOperatorCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      to : to
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* Removes `to` from operator for the `_sender`. *)
(* @Requirements:  *)
(* - `_sender` should be the token owner. Otherwise, it should throw `NotTokenOwnerError` *)
(* - `_sender` should not be `to`. Otherwise, it should throw `SelfError` *)
(* - `to` should be already an operator. Otherwise, it should throw `OperatorNotFoundError` *)
transition RemoveOperator(to: ByStr20)
  RequireNotSelf to _sender;
  has_operator <- exists operators[_sender][to];
  match has_operator with
  | False =>
    error = OperatorNotFoundError;
    Throw error
  | True =>
    (* Remove operator *)
    delete operators[_sender][to]
  end;
  e = {
    _eventname : "RemoveOperator";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_RemoveOperatorCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to : to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* Transfers `token_id` from the token owner to `to`.  *)
(* @Requirements: *)
(* - The contract should not be paused. Otherwise, it should throw `PausedError` *)
(* - `to` should not be the zero address. Otherwise, it should throw `ZeroAddressDestinationError` *)
(* - `to` should not be `_this_address`. Otherwise, it should throw `ThisAddressDestinationError` *)
(* - `token_id` should exist. Otherwise, it should throw `TokenNotFoundError` *)
(* - `_sender` should be a token owner, spender, or operator. Otherwise, it should throw `NotAllowedToTransferError` *)
(* - `_sender` should not be `to`. Otherwise, it should throw `SelfError` *)
transition TransferFrom(to: ByStr20, token_id: Uint256)
  RequireNotPaused;
  RequireValidDestination to;

  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    error = TokenNotFoundError;
    Throw error
  | Some token_owner =>
    RequireAccessToTransfer token_owner token_id;
    RequireNotSelf token_owner to;
    
    (* change token_owner for that token_id *)
    token_owners[token_id] := to;

    delete spenders[token_id];

    (* subtract one from previous token owner balance *)
    UpdateBalance sub_operation token_owner;
    (* add one to the new token owner balance *)
    UpdateBalance add_operation to;

    e = {
      _eventname : "TransferFrom";
      initiator : _sender;
      from : token_owner;
      to : to;
      token_id : token_id
    };
    event e;
    msg_to_recipient = { 
      _tag : "ZRC6_RecipientAcceptTransferFrom";
      _recipient : to;
      _amount : Uint128 0;
      from : token_owner;
      to : to;
      token_id : token_id
    };
    msg_to_sender = { 
      _tag : "ZRC6_TransferFromCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      from : token_owner;
      to : to;
      token_id : token_id
    };
    msgs = two_msgs msg_to_recipient msg_to_sender;
    send msgs
  end
end
