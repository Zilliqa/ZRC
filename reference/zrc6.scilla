scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils IntUtils
library NonfungibleToken

(* User-defined ADTs *)
type Dummy =
| Dummy

type Operation =
| Add
| Sub

(* Global variables *)
let empty_str = ""
let zero = Uint256 0
let one = Uint256 1
let verdad = Dummy
let add_operation = Add
let sub_operation = Sub
let royalty_fee_bps_min = Uint256 1
let royalty_fee_bps_max = Uint256 10000

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_bal =
  fun (opt_bal: Option Uint256) =>
    match opt_bal with
    | Some bal => bal
    | None => zero
    end

(* Error exception *)
type Error =
  | TokenNotFoundError
  | SelfError
  | NotContractOwnerError
  | NotTokenOwnerError
  | NotMinterError
  | NotSpenderOrOperatorError
  | NotOwnerOrOperatorError
  | InvalidFeeBpsError
  | MinterFoundError
  | MinterNotFoundError
  | SpenderFoundError
  | SpenderNotFoundError
  | OperatorFoundError
  | OperatorNotFoundError

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | TokenNotFoundError             => Int32 -1
      | SelfError                      => Int32 -2
      | NotContractOwnerError          => Int32 -3
      | NotTokenOwnerError             => Int32 -4
      | NotMinterError                 => Int32 -5
      | NotSpenderOrOperatorError      => Int32 -6
      | NotOwnerOrOperatorError        => Int32 -7
      | MinterFoundError               => Int32 -8
      | MinterNotFoundError            => Int32 -9
      | SpenderFoundError              => Int32 -10
      | SpenderNotFoundError           => Int32 -11
      | OperatorFoundError             => Int32 -12
      | OperatorNotFoundError          => Int32 -13
      | InvalidFeeBpsError             => Int32 -14
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NonfungibleToken
(
  contract_owner: ByStr20,
  name : String,
  symbol: String
)

(* Mutable fields *)

(* Address to send royalties to *)
(* Defaults to `contract_owner` *)
field royalty_recipient: ByStr20 = contract_owner

(* Royalty fee BPS (1/100ths of a percent, e.g. 1000 = 10%) *)
(* Defaults to 1000 *)
field royalty_fee_bps: Uint256 = Uint256 1000

(* Base URI. e.g. `https://creatures-api.zil.xyz/api/creature/` *)
(* Defaults to empty string *)
field base_uri: String = empty_str

(* Mapping from token ID to its owner *)
field token_owners: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* The total number of tokens minted *)
field token_id_count: Uint256 = Uint256 0

(* The total number of existing tokens *)
field total_supply: Uint256 = Uint256 0

(* Mapping from token owner to the number of existing tokens *)
field balances: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Set for minters *)
(* `contract_owner` is a minter by default *)
field minters: Map ByStr20 Dummy =
    let emp_map = Emp ByStr20 Dummy in
    builtin put emp_map contract_owner verdad

(* Mapping from token ID to a spender *)
field spenders: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from token owner to operators authorized by the token owner *)
field operators: Map ByStr20 (Map ByStr20 Dummy) = Emp ByStr20 (Map ByStr20 Dummy)

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsValidRoyaltyFeeBPS(fee_bps: Uint256)
  is_gte_min = uint256_ge fee_bps royalty_fee_bps_min;
  is_lte_max = uint256_le fee_bps royalty_fee_bps_max;
  
  is_valid = andb is_gte_min is_lte_max;
  match is_valid with 
    | True => 
    | False =>
      err = InvalidFeeBpsError;
      ThrowError err
  end
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = NotContractOwnerError;
    ThrowError err
  end
end

procedure IsNotSelf(address_a: ByStr20, address_b: ByStr20)
  is_self = builtin eq address_a address_b;
  match is_self with
  | False =>
  | True =>
    err = SelfError;
    ThrowError err
  end
end

procedure IsTokenFound(token_id: Uint256)
  has_token <- exists token_owners[token_id];
  match has_token with
  | True =>
  | False =>
    err = TokenNotFoundError;
    ThrowError err
  end
end

procedure IsMinter(address: ByStr20)
  has_minter <- exists minters[address];
  match has_minter with
  | True =>
  | False =>
    err = NotMinterError;
    ThrowError err
  end
end

procedure IsTokenOwner(token_id: Uint256, address: ByStr20)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | Some addr => 
    is_token_owner = builtin eq addr address;
    match is_token_owner with
    | True =>
    | False =>
      err = NotTokenOwnerError;
      ThrowError err
    end
  | None =>
    err = TokenNotFoundError;
    ThrowError err
  end
end

procedure IsOwnerOrOperator(token_owner: ByStr20)
  is_owner = builtin eq _sender token_owner;
  has_operator <- exists operators[token_owner][_sender];
  is_authorized = orb is_owner has_operator;
  match is_authorized with
  | True =>
  | False =>
    err = NotOwnerOrOperatorError;
    ThrowError err
  end
end

procedure IsSpenderOrOperator(token_id: Uint256, token_owner: ByStr20)
  opt_spender <- spenders[token_id];
  is_spender = match opt_spender with
    | None => False
    | Some spender => 
      builtin eq _sender spender
    end;
  has_operator <- exists operators[token_owner][_sender];
  is_authorized = orb is_spender has_operator;
  match is_authorized with
  | True =>
  | False =>
    err = NotSpenderOrOperatorError;
    ThrowError err
  end
end

procedure UpdateBalance(operation: Operation, address: ByStr20)
  match operation with
  | Add =>
    opt_to_count <- balances[address];
    new_to_count = 
      let current_count = get_bal opt_to_count in
      builtin add current_count one;
    balances[address] := new_to_count
  | Sub =>
    opt_from_count <- balances[address];
    new_from_count = 
      let current_count = get_bal opt_from_count in
        let is_zero = builtin eq current_count zero in
          match is_zero with
          | True => zero
          | False => builtin sub current_count one
          end;
    balances[address] := new_from_count
  end
end

procedure MintToken(to: ByStr20)
  IsMinter _sender;

  (* generate ID *)
  current_token_id_count <- token_id_count;
  new_token_id_count = builtin add current_token_id_count one;
  token_id_count := new_token_id_count;
  token_id = new_token_id_count;

  (* mint a new token *)
  token_owners[token_id] := to;

  (* add one to the token owner balance *)
  UpdateBalance add_operation to;
  
  (* add one to the total supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply;
  
  e = {
    _eventname : "MintSuccess";
    initiator : _sender;
    to : to;
    token_id : token_id
  };
  event e
end

(* @dev Gets royalty payment information for `token_id` and `sale_price`.    *)
(* It specifies how much royalty is owed and to whom for a given sale price. *)
transition RoyaltyInfo(token_id: Uint256, sale_price: Uint256)
  IsTokenFound token_id;

  current_royalty_fee_bps <- royalty_fee_bps;
  current_royalty_recipient <- royalty_recipient;

  x = builtin div royalty_fee_bps_max current_royalty_fee_bps;
  royalty_amount = builtin div sale_price x;

  msg_to_sender = { 
    _tag : "ZRC6_RoyaltyInfoCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_recipient : current_royalty_recipient;
    royalty_amount : royalty_amount
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets Uniform Resource Identifier(URI) for `token_id` *)
transition TokenURI(token_id: Uint256)
  IsTokenFound token_id;

  uri <- base_uri;

  is_empty = builtin eq uri empty_str;
  
  token_uri = match is_empty with
    | True => empty_str
    | False => 
      let id = builtin to_string token_id in
      builtin concat uri id
    end;

  msg_to_sender = { 
    _tag : "ZRC6_TokenURICallback";
    _recipient : _sender;
    _amount : Uint128 0;
    token_uri : token_uri
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets token owner for `token_id` *)
transition OwnerOf(token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | Some token_owner =>
    msg_to_sender = { 
      _tag : "ZRC6_OwnerOfCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      token_owner : token_owner
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None =>
    err = TokenNotFoundError;
    ThrowError err
  end
end

(* @dev: Gets the NFT name *)
transition Name()
  msg_to_sender = {
    _tag : "ZRC6_NameCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    name : name
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets the NFT symbol *)
transition Symbol()
  msg_to_sender = {
    _tag : "ZRC6_SymbolCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    symbol : symbol
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets the number of tokens in `owner`s account *)
transition BalanceOf(address: ByStr20)
  opt_bal <- balances[address];
  balance = get_bal opt_bal;
  msg_to_sender = { 
    _tag : "ZRC6_BalanceOfCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    balance : balance
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets total amount of tokens stored by the contract *)
transition TotalSupply()
  current_supply <- total_supply;
  msg_to_sender = { 
    _tag : "ZRC6_TotalSupplyCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    total_supply : current_supply
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Gets spender for `token_id` *)
transition GetSpender(token_id: Uint256)
  IsTokenFound token_id;

  opt_spender <- spenders[token_id];
  match opt_spender with
  | Some spender => 
    msg_to_sender = { 
      _tag : "ZRC6_GetSpenderCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      spender : spender;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None => 
    err = SpenderNotFoundError;
    ThrowError err
  end
end

(* @dev: Checks if `operator` is allowed to manage all of the assets of `token_owner` *)
transition IsOperator(token_owner: ByStr20, operator: ByStr20)
  has_operator <- exists operators[token_owner][operator];
  msg_to_sender = { 
    _tag : "ZRC6_IsOperatorCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    is_operator: has_operator
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Sets `to` as the royalty recipient. *)
(* Only contract_owner can be _sender.       *)
(* @param: to - Royalty recipient address    *)
transition SetRoyaltyRecipient(to: ByStr20)
  IsContractOwner;
  royalty_recipient := to;
  
  e = { 
    _eventname : "SetRoyaltyRecipientSuccess";
    initiator : _sender;
    to : to
  };
  event e;
  
  msg_to_sender = { 
    _tag : "ZRC6_SetRoyaltyRecipientCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    to : to
  };
  msgs = one_msg msg_to_sender;
  send msgs  
end

(* @dev: Sets `fee_bps` as royalty fee bps.      *)
(* Only contract_owner can be _sender.           *)
(* Fee bps should be in the range of 1 and 1000. *)
(* @param: fee_bps - Royalty fee BPS             *)
transition SetRoyaltyFeeBPS(fee_bps: Uint256)
  IsContractOwner;
  IsValidRoyaltyFeeBPS fee_bps;
  royalty_fee_bps := fee_bps;
  
  e = { 
    _eventname : "SetRoyaltyFeeBPSSuccess";
    initiator : _sender; 
    royalty_fee_bps : fee_bps
  };
  event e;

  msg_to_sender = { 
    _tag : "ZRC6_SetRoyaltyFeeBPSCallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    royalty_fee_bps : fee_bps
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Sets `uri` as the base URI. *)
(* Only contract_owner can be _sender.    *)
transition SetBaseURI(uri: String)
  IsContractOwner;
  base_uri := uri;

  e = { 
    _eventname : "SetBaseURISuccess";
    initiator : _sender;
    base_uri : uri
  };
  event e;
  
  msg_to_sender = { 
    _tag : "ZRC6_SetBaseURICallback"; 
    _recipient : _sender;
    _amount : Uint128 0;
    base_uri : uri
  };
  msgs = one_msg msg_to_sender;
  send msgs  
end

(* @dev: Mints a token and transfers it to `to`. *)
(* Only minter can be _sender.                   *)
(* @param: to - Address of the token recipient   *)
transition Mint(to: ByStr20)
  MintToken to;
  token_id <- token_id_count;
  msg_to_recipient = { 
    _tag : "ZRC6_RecipientAcceptMint";
    _recipient : to;
    _amount : Uint128 0
  };
  msg_to_sender = { 
    _tag : "ZRC6_MintCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to : to;
    token_id : token_id
  };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev: Mints tokens and transfers them to `to_list`.        *)
(* Only minter can be _sender.                                *)
(* @param: to_list - List of addresses of the token recipient *)
transition BatchMint(to_list: List ByStr20)
  forall to_list MintToken;
  msg_to_sender = { 
    _tag : "ZRC6_BatchMintCallback";
    _recipient : _sender;
    _amount : Uint128 0
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Destroys `token_id`                               *)
(* Only token_owner or operator can be _sender.            *)
(* @param: token_id - Unique ID of the NFT to be destroyed *)
transition Burn(token_id: Uint256)
  (* Check if token exists *)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = TokenNotFoundError;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperator token_owner;
    (* Destroy existing token *)
    delete token_owners[token_id];
    delete spenders[token_id];

    (* subtract one from the balance *)
    UpdateBalance sub_operation token_owner;
    (* subtract one from the total supply *)
    current_supply <- total_supply;
    new_supply = builtin sub current_supply one;
    total_supply := new_supply;
    e = {
      _eventname : "BurnSuccess";
      initiator : _sender;
      burn_address : token_owner;
      token_id : token_id
    };
    event e;
    msg_to_sender = { 
      _tag : "ZRC6_BurnCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      burn_address : token_owner;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* @dev: Adds `to` as minter           *)
(* Only contract_owner can be _sender. *)
transition AddMinter(to: ByStr20)
  IsContractOwner;
  has_minter <- exists minters[to];
  match has_minter with
  | True => 
    err = MinterFoundError;
    ThrowError err
  | False =>
    (* Add minter *)
    minters[to] := verdad
  end;
  e = { 
    _eventname : "AddMinterSuccess";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_AddMinterCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to: to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Removes `to` from minter      *)
(* Only contract_owner can be _sender. *)
transition RemoveMinter(to: ByStr20)
  IsContractOwner;
  has_minter <- exists minters[to];
  match has_minter with
  | True => 
    delete minters[to]
  | False =>
    err = MinterNotFoundError;
    ThrowError err
  end;
  e = { 
    _eventname : "RemoveMinterSuccess";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_RemoveMinterCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to: to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Adds `to` as spender of `token_id`                   *)
(* Only token_owner or operator can be _sender.               *)
(* There can only be one spender per token at any given time. *)
transition AddSpender(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = TokenNotFoundError;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperator token_owner;
    
    has_spender <- exists spenders[token_id];
    match has_spender with
      | True =>
      err = SpenderFoundError;
      ThrowError err
      | False =>
      (* Add spender *)
      spenders[token_id] := to
    end;
    
    e = {
      _eventname : "AddSpenderSuccess";
      initiator : _sender;
      to : to;
      token_id : token_id
    };
    event e;
    
    msg_to_sender = { 
      _tag : "ZRC6_AddSpenderCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      to : to;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* @dev: Removes `to` from spender of `token_id`              *)
(* Only token_owner or operator can be _sender.               *)
transition RemoveSpender(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = TokenNotFoundError;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperator token_owner;
    
    has_spender <- exists spenders[token_id];
    match has_spender with
    | True =>
      (* Remove spender *)
      delete spenders[token_id]
    | False =>
      err = SpenderNotFoundError;
      ThrowError err
    end;
    
    e = {
      _eventname : "RemoveSpenderSuccess";
      initiator : _sender;
      to : to;
      token_id : token_id
    };
    event e;

    msg_to_sender = { 
      _tag : "ZRC6_RemoveSpenderCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      to : to;
      token_id : token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* @dev: Adds `to` as operator for the _sender *)
transition AddOperator(to: ByStr20)
  IsNotSelf to _sender;
  has_operator <- exists operators[_sender][to];
  match has_operator with
  | False =>
    (* Add operator *)
    operators[_sender][to] := verdad
  | True =>
    err = OperatorFoundError;
    ThrowError err
  end;
  e = {
    _eventname : "AddOperatorSuccess";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_AddOperatorCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to : to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Removes `to` from operator for the _sender *)
transition RemoveOperator(to: ByStr20)
  IsNotSelf to _sender;
  has_operator <- exists operators[_sender][to];
  match has_operator with
  | False =>
    err = OperatorNotFoundError;
    ThrowError err
  | True =>
    (* Remove operator *)
    delete operators[_sender][to]
  end;
  e = {
    _eventname : "RemoveOperatorSuccess";
    initiator : _sender;
    to : to
  };
  event e;
  msg_to_sender = { 
    _tag : "ZRC6_RemoveOperatorCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    to : to
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Transfers `token_id` from the token owner to `to`.  *)
(* Only token_owner can be _sender.                          *)
transition Transfer(to: ByStr20, token_id: Uint256)
  IsNotSelf to _sender;
  IsTokenOwner token_id _sender;
  (* Change token_owner for that token_id *)
  token_owners[token_id] := to;

  delete spenders[token_id];
  (* subtract one from previous token owner balance *)
  UpdateBalance sub_operation _sender;
  (* add one to the new token owner balance *)
  UpdateBalance add_operation to;
  e = {
    _eventname : "TransferSuccess";
    initiator : _sender;
    from : _sender;
    to : to;
    token_id : token_id
  };
  event e;

  msg_to_recipient = { 
    _tag : "ZRC6_RecipientAcceptTransfer";
    _recipient : to;
    _amount : Uint128 0;
    from : _sender;
    to : to;
    token_id : token_id
  };

  msg_to_sender = { 
    _tag : "ZRC6_TransferCallback";
    _recipient : _sender;
    _amount : Uint128 0;
    from : _sender;
    to : to;
    token_id : token_id
  };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev: Transfers `token_id` from the token owner to `to`.  *)
(* Only spender or operator can be _sender.                  *)
transition TransferFrom(to: ByStr20, token_id: Uint256)
  opt_token_owner <- token_owners[token_id];
  match opt_token_owner with
  | None =>
    err = TokenNotFoundError;
    ThrowError err
  | Some token_owner =>
    IsNotSelf to token_owner;
    IsSpenderOrOperator token_id token_owner;
    (* Change token_owner for that token_id *)
    token_owners[token_id] := to;

    delete spenders[token_id];
    (* subtract one from previous token owner balance *)
    UpdateBalance sub_operation token_owner;
    (* add one to the new token owner balance *)
    UpdateBalance add_operation to;
    e = {
      _eventname : "TransferFromSuccess";
      initiator : _sender;
      from : token_owner;
      to : to;
      token_id : token_id
    };
    event e;
    msg_to_recipient = { 
      _tag : "ZRC6_RecipientAcceptTransferFrom";
      _recipient : to;
      _amount : Uint128 0;
      from : token_owner;
      to : to;
      token_id : token_id
    };
    msg_to_sender = { 
      _tag : "ZRC6_TransferFromCallback";
      _recipient : _sender;
      _amount : Uint128 0;
      from : token_owner;
      to : to;
      token_id : token_id
    };
    msgs = two_msgs msg_to_recipient msg_to_sender;
    send msgs
  end
end
